# 씬 전환 로직 최적화 수정사항

## 문제점 분석

기존 씬 전환 로직에서 발견된 문제점들:

1. **변환 미리보기 관련 문제**
   - 씬 전환 시 과도한 미리보기 생성으로 인한 성능 저하
   - 레이어 상태 변경 시 불필요한 미리보기 재생성
   - 캔버스 준비 상태 체크 부족으로 인한 오류 발생

2. **순환 참조 문제**
   - `debouncedGeneratePreview` 함수가 정의되기 전에 useEffect에서 참조
   - 함수 초기화 순서 문제로 인한 ReferenceError

3. **캔버스 팬(Pan) 이동과 미리보기 시점 문제**
   - 캔버스를 팬으로 이동시키면 미리보기도 함께 이동
   - 미리보기는 항상 원본 위치 기준으로 생성되어야 함
   - `exportCanvasAsImage()` 함수가 현재 viewport 상태를 그대로 캡처

## 수정사항

### 1. 씬 전환 시 미리보기 생성 최적화

**파일**: `frontend/src/components/PreviewPanel.jsx`

#### 변경 전:
```javascript
// sceneId 변경 시 미리보기 상태 초기화
useEffect(() => {
  console.log('씬 변경됨, 미리보기 상태 초기화:', sceneId);
  setPreviewImage(null);
  setCanConfirm(false);
  setError(null);
  setIsGeneratingPreview(false);
}, [sceneId]);
```

#### 변경 후:
```javascript
// 디바운스된 미리보기 생성 (함수 정의를 먼저 배치)
const debouncedGeneratePreview = useCallback(() => {
  if (debounceTimerRef.current) {
    clearTimeout(debounceTimerRef.current);
  }
  debounceTimerRef.current = setTimeout(generatePreview, 700); // 0.7초 지연
}, [generatePreview]);

// sceneId 변경 시 미리보기 상태 초기화 후 새로 생성
useEffect(() => {
  console.log('씬 변경됨, 미리보기 상태 초기화:', sceneId);
  setPreviewImage(null);
  setCanConfirm(false);
  setError(null);
  setIsGeneratingPreview(false);
  
  // 디바운스 타이머 초기화 후 새 씬의 미리보기 생성
  if (debounceTimerRef.current) {
    clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = null;
  }
  
  // 씬 전환 후 새로운 미리보기 생성
  if (enabled && stageRef.current && sceneId) {
    debouncedGeneratePreview();
  }
}, [sceneId, enabled, debouncedGeneratePreview]);
```

### 2. 캔버스 준비 상태 체크 강화

#### 변경 전:
```javascript
const generatePreview = useCallback(async () => {
  if (!enabled || !stageRef.current || isGeneratingPreview || processing || !projectId || !sceneId) {
    return;
  }
```

#### 변경 후:
```javascript
const generatePreview = useCallback(async () => {
  if (!enabled || !stageRef.current || isGeneratingPreview || processing || !projectId || !sceneId) {
    return;
  }

  // 캔버스가 완전히 준비되었는지 추가 확인
  if (!stageRef.current.exportCanvasAsImage || typeof stageRef.current.exportCanvasAsImage !== 'function') {
    console.log('미리보기 취소: 캔버스 API가 아직 준비되지 않음');
    return;
  }
```

### 3. 레이어 변경 시 미리보기 트리거 최적화

#### 변경 전:
```javascript
// 레이어 변경 시에만 별도 미리보기 트리거
useEffect(() => {
  if (enabled && stageRef.current && sceneId && layersState.length > 0) {
    debouncedGeneratePreview();
  }
}, [layersState]); // 레이어 상태 변경시 트리거 (내용, 활성 레이어 등)
```

#### 변경 후:
```javascript
// 레이어 변경 시 미리보기 트리거
useEffect(() => {
  if (enabled && stageRef.current && sceneId && layersState.length > 0) {
    debouncedGeneratePreview();
  }
}, [layersState, enabled, sceneId, debouncedGeneratePreview]); // 레이어 상태 변경시 트리거
```

### 4. 순환 참조 문제 해결

**문제**: `debouncedGeneratePreview` 함수가 정의되기 전에 useEffect에서 참조되어 ReferenceError 발생

**해결책**: 
- `debouncedGeneratePreview` useCallback을 useEffect보다 먼저 배치
- 중복된 함수 정의 제거

### 5. 캔버스 팬 이동과 미리보기 시점 분리

**파일**: `frontend/src/components/Canvas.jsx`

#### 변경 전:
```javascript
// 현재 캔버스 전체를 이미지로 내보내기
const exportCanvasAsImage = () => {
  if (!fabricCanvas.current) return null;

  const canvas = fabricCanvas.current;
  // 캔버스를 데이터 URL로 변환 (PNG 형태)
  const dataURL = canvas.toDataURL({
    format: "png",
    quality: 1.0,
    multiplier: 1,
  });

  return dataURL;
};
```

#### 변경 후:
```javascript
// 현재 캔버스 전체를 이미지로 내보내기 (원본 위치 기준, 팬 이동 무시)
const exportCanvasAsImage = () => {
  if (!fabricCanvas.current) return null;

  const canvas = fabricCanvas.current;
  
  // 현재 viewport 변환 정보 저장
  const currentViewportTransform = canvas.viewportTransform ? [...canvas.viewportTransform] : null;
  
  try {
    // 일시적으로 viewport를 원점으로 리셋 (팬 이동 취소)
    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
    
    // 원본 위치 기준으로 캔버스를 데이터 URL로 변환
    const dataURL = canvas.toDataURL({
      format: "png",
      quality: 1.0,
      multiplier: 1,
    });
    
    return dataURL;
  } finally {
    // viewport 변환을 원래대로 복원
    if (currentViewportTransform) {
      canvas.setViewportTransform(currentViewportTransform);
    }
  }
};
```

## 개선 효과

1. **안정성 향상**
   - 캔버스 API 준비 상태 체크로 오류 방지
   - 순환 참조 문제 해결
   - viewport 변환 복원 보장 (try-finally 구문 사용)

2. **사용자 경험 개선**
   - 씬 전환 시 적절한 미리보기 생성
   - 각 씬마다 변환 미리보기 제공
   - **캔버스 팬 이동과 무관한 일관된 미리보기 시점**

3. **성능 최적화**
   - 불필요한 미리보기 재생성 방지
   - 적절한 디바운스 시간 (700ms) 유지

4. **기능 정확성 향상**
   - 미리보기가 항상 원본 위치 기준으로 생성
   - 사용자의 캔버스 조작(팬 이동)이 변환 결과에 영향을 주지 않음

## 변환 상태 식별 방식

현재 시스템에서 변환된 씬인지 식별하는 방식:

```javascript
// EditorPage.jsx
const isSceneTransformed = useMemo(() => {
  if (!selectedScene) return false;
  return selectedScene.saveMode === 'processed' || selectedScene.isTransformed === true;
}, [selectedScene]);
```

- 서버에서 받은 데이터의 `saveMode`나 `isTransformed` 플래그로 판단
- `s3_key`가 'processed'로 시작하는지도 체크
- 미리보기는 **완전히 클라이언트 딴에서 처리** (서버 통신 없음)

## 최종 동작 플로우

1. **씬 전환 시**:
   - 미리보기 상태 초기화
   - 디바운스 타이머 리셋
   - 새로운 씬의 미리보기 생성

2. **레이어/캔버스 변경 시**:
   - 디바운스된 미리보기 재생성 (700ms 지연)

3. **미리보기 이미지 생성 시**:
   - 현재 viewport 변환 정보 백업
   - viewport를 원점으로 일시적 리셋
   - 원본 위치 기준으로 이미지 캡처
   - viewport 변환을 원상복구

4. **변환 전 씬에서만**:
   - 미리보기 패널 표시
   - 변환 버튼 활성화
   - **팬 이동과 무관한 고정 시점 미리보기**

5. **변환 후 씬에서는**:
   - 미리보기 패널 숨김
   - "변환 완료" 상태 표시

## 주요 기술적 개선

### viewport 변환 매트릭스 처리
```javascript
// 원본 위치: [1, 0, 0, 1, 0, 0] (변환 없음)
// 팬 이동 후: [1, 0, 0, 1, offsetX, offsetY] (x, y만큼 이동)
// 줌 + 팬: [scale, 0, 0, scale, offsetX, offsetY]

const currentViewportTransform = canvas.viewportTransform ? [...canvas.viewportTransform] : null;
canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // 원점 리셋
// 이미지 캡처 작업
canvas.setViewportTransform(currentViewportTransform); // 복원
```

이제 사용자가 어떻게 캔버스를 조작해도 변환 미리보기는 항상 일관된 시점에서 생성됩니다.